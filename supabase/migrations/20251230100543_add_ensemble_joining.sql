drop extension if exists "pg_net";


  create table "public"."ensemble_memberships" (
    "user_id" uuid not null,
    "ensemble_id" bigint not null,
    "role" text not null default 'waiting_approval'::text,
    "requested_at" timestamp with time zone not null default now(),
    "approved_at" timestamp with time zone
      );


alter table "public"."ensemble_memberships" enable row level security;


  create table "public"."ensembles" (
    "id" bigint generated by default as identity not null,
    "name" text not null,
    "created_at" timestamp with time zone not null default now(),
    "code" text
      );


alter table "public"."ensembles" enable row level security;

CREATE UNIQUE INDEX ensemble_memberships_pkey ON public.ensemble_memberships USING btree (user_id, ensemble_id);

CREATE UNIQUE INDEX ensembles_pkey ON public.ensembles USING btree (id);

alter table "public"."ensemble_memberships" add constraint "ensemble_memberships_pkey" PRIMARY KEY using index "ensemble_memberships_pkey";

alter table "public"."ensembles" add constraint "ensembles_pkey" PRIMARY KEY using index "ensembles_pkey";

alter table "public"."ensemble_memberships" add constraint "ensemble_memberships_ensemble_id_fkey" FOREIGN KEY (ensemble_id) REFERENCES public.ensembles(id) ON DELETE CASCADE not valid;

alter table "public"."ensemble_memberships" validate constraint "ensemble_memberships_ensemble_id_fkey";

alter table "public"."ensemble_memberships" add constraint "ensemble_memberships_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."ensemble_memberships" validate constraint "ensemble_memberships_user_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.attempt_join_ensemble(p_name text, p_code text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  ensemble record;
  has_code boolean;
begin
  select * from ensembles where name = p_name into ensemble;

  has_code := (ensemble.code is not null and ensemble.code <> '');

  if ensemble is null then
    raise exception 'Ensemble % not found', p_name;
  end if;

  if has_code then
    if not (p_code is not null and (select (ensemble.code = crypt(p_code, ensemble.code)))) then
      raise exception 'Invalid code for ensemble %', p_name;
    end if;
  end if;

  insert into ensemble_memberships (ensemble_id, user_id, role, approved_at)
  select ensemble.id, (select auth.uid()), 
    case when has_code then 'member' else 'awaiting_approval' end,
    case when has_code then now() else null end
  on conflict do nothing;

  return true;
end;
$function$
;

grant delete on table "public"."ensemble_memberships" to "anon";

grant insert on table "public"."ensemble_memberships" to "anon";

grant references on table "public"."ensemble_memberships" to "anon";

grant select on table "public"."ensemble_memberships" to "anon";

grant trigger on table "public"."ensemble_memberships" to "anon";

grant truncate on table "public"."ensemble_memberships" to "anon";

grant update on table "public"."ensemble_memberships" to "anon";

grant delete on table "public"."ensemble_memberships" to "authenticated";

grant insert on table "public"."ensemble_memberships" to "authenticated";

grant references on table "public"."ensemble_memberships" to "authenticated";

grant select on table "public"."ensemble_memberships" to "authenticated";

grant trigger on table "public"."ensemble_memberships" to "authenticated";

grant truncate on table "public"."ensemble_memberships" to "authenticated";

grant update on table "public"."ensemble_memberships" to "authenticated";

grant delete on table "public"."ensemble_memberships" to "service_role";

grant insert on table "public"."ensemble_memberships" to "service_role";

grant references on table "public"."ensemble_memberships" to "service_role";

grant select on table "public"."ensemble_memberships" to "service_role";

grant trigger on table "public"."ensemble_memberships" to "service_role";

grant truncate on table "public"."ensemble_memberships" to "service_role";

grant update on table "public"."ensemble_memberships" to "service_role";

grant delete on table "public"."ensembles" to "anon";

grant insert on table "public"."ensembles" to "anon";

grant references on table "public"."ensembles" to "anon";

grant select on table "public"."ensembles" to "anon";

grant trigger on table "public"."ensembles" to "anon";

grant truncate on table "public"."ensembles" to "anon";

grant update on table "public"."ensembles" to "anon";

grant delete on table "public"."ensembles" to "authenticated";

grant insert on table "public"."ensembles" to "authenticated";

grant references on table "public"."ensembles" to "authenticated";

grant select on table "public"."ensembles" to "authenticated";

grant trigger on table "public"."ensembles" to "authenticated";

grant truncate on table "public"."ensembles" to "authenticated";

grant update on table "public"."ensembles" to "authenticated";

grant delete on table "public"."ensembles" to "service_role";

grant insert on table "public"."ensembles" to "service_role";

grant references on table "public"."ensembles" to "service_role";

grant select on table "public"."ensembles" to "service_role";

grant trigger on table "public"."ensembles" to "service_role";

grant truncate on table "public"."ensembles" to "service_role";

grant update on table "public"."ensembles" to "service_role";


  create policy "Enable delete for users based on user_id"
  on "public"."ensemble_memberships"
  as permissive
  for delete
  to public
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable users to view their own data only"
  on "public"."ensemble_memberships"
  as permissive
  for select
  to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));



  create policy "Enable read access for all users"
  on "public"."ensembles"
  as permissive
  for select
  to public
using (true);



